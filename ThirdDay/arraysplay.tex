\documentclass[twoside]{article}
\title{Lesson with Arrays and Pointers}
\author{CSC315 Programming Language Concepts}
\date{04 October 2017}
\usepackage{listings}
\lstset{language=c}
\lstset{numbers=left, showspaces=false, showstringspaces=false}

\newenvironment{answer}
  { \vspace*{12pt}

    \rule{12cm}{0.02cm}

    \vspace*{12pt}

    \hspace*{1.0cm}
    \begin{minipage}{10cm}}
  {\end{minipage} \vspace*{12pt}}

\begin{document}
\maketitle

\begin{enumerate}
  \item What does the statement \lstinline@int* np = &n;@ accomplish?

  \begin{answer}
    It assigns the address of a variable named \lstinline@n@ to 
    a variable named \lstinline@np@.
    \end{answer}

	\item How does an unsigned long differ from a normal one?
	
	\begin{answer}
		Unsigned longs don't store negative numbers, 
		but can store larger positive numbers.
		\end{answer}
	\begin{enumerate}
  \item Why do the fibonacci addresses go up by 4s?

  \begin{answer}
	Because they are 4 bytes large.
    \end{answer}
	
	\item What happens when you printf the address of a array where no number
	is stored?
	
	\being{answer}
	It makes a really large number
	\end{answer}
	
	
  \end{enumerate}
  

\section{Source code}

\begin{lstlisting}{}
#include <stdio.h>
#include <stdlib.h>

void f( int n ) {
  n = 42;
} // f( int )

void g( int *np ) {
  *np = 42;
} // g( int* )

int fibonacci(int n){
  if (n==0){
    return 0;
  }
  if (n==1){
    return 1;
  }
  return fibonacci(n-1) + fibonacci(n-2);
}


int main( int argc, char** argv ) {
  // create an array in a familiar way
  int fib;
  printf("Enter fibonacci number:");
  scanf("%d", &fib);
  printf("%d", fibonacci(fib));
  printf("\n");
  int primes[8];
  primes[0] = 2;
  primes[1] = 3;
  primes[2] = 5;
  primes[3] = 7;
  primes[4] = 11;
  primes[5] = 13;
  primes[6] = 17;
  primes[7] = 19;

  // access elements with both index and pointer plus offset
  printf( "primes[0]     = %2d\n", primes[0] );
  printf( "*primes       = %2d\n", *primes );

  printf( "\n" );

  printf( "primes[1]     = %2d\n", primes[1] );
  printf( "*(primes + 1) = %2d\n", *(primes + 1) );

  printf( "\n" );

  printf( "primes[2]     = %2d\n", primes[2] );
  printf( "*(primes + 2) = %2d\n", *(primes + 2) );

  printf( "\n" );

  printf( "primes[3]     = %2d\n", primes[3] );
  printf( "*(primes + 3) = %2d\n", *(primes + 3) );

  printf( "\n" );

  *(primes + 7) = 21;
  printf( "primes[7] = %d\n", primes[7] );

  printf( "\n" );

  // another way to create an array
  int* fibonacci = (int*) malloc( 8 * sizeof(int) );
  // assign values using name of array plus index
  fibonacci[0] = 1;
  fibonacci[1] = 1;
  fibonacci[2] = 2;
  fibonacci[3] = 3;
  // assign values using address of start of
  // block of memory plus offset
  *(fibonacci + 4) = 5;
  *(fibonacci + 5) = 8;
  *(fibonacci + 6) = 13;
  *(fibonacci + 7) = 21;

  int i;
  for( i = 0; i < 8; i++ ) {
    printf( "fibonacci[%1d] = %2d\n", i, fibonacci[i] );
  } // for
  
  //messing around
  printf("fibonacci[%1d] = %2d\n", 8, fibonacci[8]);

  printf( "\n" );

  for( i = 0; i < 8; i++ ) {
    printf( "address of fibonacci[%1d] = %lu\n",
        i, (unsigned long) (fibonacci + i) );
  } // for
  
  //messing around
  printf("address of fibonacci[%1d] = %lu\n", 8, 
	 (unsigned long) (fibonacci + 8));

  printf( "\n" );

  int oneInteger = 27;
  printf( "before call to f(), oneInteger = %d\n", oneInteger );
  f( oneInteger );
  printf( "after call to f(), oneInteger  = %d\n", oneInteger );
 
  printf( "\n" );

  int oneIntegerArray[1];
  oneIntegerArray[0] = 27;
  printf( "before call to g(), oneIntegerArray[0] = %d\n",
      oneIntegerArray[0] );
  printf( "before call to g(), ");
  printf( "address of oneIntegerArray[0] = %lu\n",
      (unsigned long) &oneIntegerArray[0] );
  g( oneIntegerArray );
  printf( "after call to g(), oneIntegerArray[0]  = %d\n",
      oneIntegerArray[0] );
  printf( "after call to g(), " );
  printf( "address of oneIntegerArray[0]  = %lu\n",
      (unsigned long) &oneIntegerArray[0] );
  
} // main( int, char** )

  \end{lstlisting}

\end{document}
